<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OLX Interactive Parser</title>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; margin: 0; padding: 0; }
        .container { max-width: 600px; margin: 60px auto; background: #fff; padding: 32px 24px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
        h1 { text-align: center; color: #333; }
        form { display: flex; flex-direction: column; gap: 16px; }
        label { font-weight: bold; color: #555; margin-bottom: -8px; }
        input[type="file"] { padding: 8px; }
        input[type="text"] { padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        input[type="text"]:focus { outline: none; border-color: #007bff; }
        .help-text { font-size: 12px; color: #666; margin-top: -8px; }
        button { background: #007bff; color: #fff; border: none; padding: 12px; border-radius: 4px; font-size: 16px; cursor: pointer; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .progress-container { display: none; margin-top: 10px; }
        .progress-bar { width: 100%; height: 20px; background: #e9ecef; border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background: #007bff; transition: width 0.3s; }
        .progress-text { text-align: center; margin-top: 5px; color: #666; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>OLX Interactive Parser</h1>
        <p style="text-align: center; margin-bottom: 20px;">
            <a href="/cleaner" style="color: #007bff; text-decoration: none; font-weight: bold; padding: 8px 16px; border: 2px solid #007bff; border-radius: 4px; display: inline-block;">ðŸ§¹ HTML Style Cleaner</a>
        </p>
        <p style="color:#b94a48; font-weight:bold; margin-top:1em;">
            ðŸš¨ Files must be under <strong>5MB</strong> after processing.<br>
            <em>âœ¨ <strong>Good news!</strong> If your OLX has a bloated <code>/static/</code> folder, we'll automatically remove it <strong>in your browser</strong> before uploading. A 1GB file can shrink to 1MB! No more manual cleanup needed.</em>
        </p>
        <form id="uploadForm" method="post" enctype="multipart/form-data" action="/upload">
            <label for="olxfile">OLX File (tar.gz, zip, or tgz)</label>
            <input type="file" id="olxfile" name="olxfile" required>
            
            <label for="course_id">Course ID (Optional)</label>
            <input type="text" id="course_id" name="course_id" placeholder="MITx+Template.Course+06_17_2025" value="MITx+Template.Course+06_17_2025">
            <div class="help-text">ðŸ’¡ Enter your course ID to make problem links clickable in Studio. Format: Org+Course+Run</div>
            
            <label for="studio_base_url">Studio Base URL (Optional)</label>
            <input type="text" id="studio_base_url" name="studio_base_url" placeholder="https://studio.courses.rc.learn.mit.edu" value="https://studio.courses.rc.learn.mit.edu">
            <div class="help-text">ðŸ’¡ Base URL for your Studio instance (e.g., https://studio.courses.rc.learn.mit.edu)</div>
            
            <div style="display: flex; gap: 10px;">
                <button type="submit" id="submitBtn" style="flex: 1;">Clean and Upload and Parse</button>
            </div>
          <hr>
            <div class="help-text">Use the following button to remove /static and download the file.</div>
            <div style="display: flex; gap: 10px;">
              <button type="button" id="cleanBtn" style="flex: 1; background: #28a745;">Clean and Download</button>
          </div>
          </form>
          
          <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Processing...</div>
          </div>
          
          <script>
          const uploadForm = document.getElementById('uploadForm');
          const fileInput = document.getElementById('olxfile');
          const submitBtn = document.getElementById('submitBtn');
          const cleanBtn = document.getElementById('cleanBtn');
          const progressContainer = document.getElementById('progressContainer');
          const progressFill = document.getElementById('progressFill');
          const progressText = document.getElementById('progressText');

          function updateProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
          }

          function showProgress() {
            progressContainer.style.display = 'block';
            submitBtn.disabled = true;
            cleanBtn.disabled = true;
          }

          function hideProgress() {
            progressContainer.style.display = 'none';
            submitBtn.disabled = false;
            cleanBtn.disabled = false;
          }

          // Helper to convert tar.gz to clean tar.gz using a simpler approach
          async function cleanTarGz(file) {
            if (typeof pako === 'undefined') {
              throw new Error('Compression library not loaded. Please refresh the page.');
            }
            
            updateProgress(10, 'Reading file...');
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            updateProgress(30, 'Decompressing...');
            
            // Decompress gzip
            const decompressed = pako.ungzip(uint8Array);
            
            updateProgress(50, 'Filtering out /static directory...');
            
            // Simple approach: create a new tar by copying blocks, skipping static entries
            const newTarBlocks = [];
            let offset = 0;
            
            while (offset < decompressed.length) {
              if (decompressed[offset] === 0) break; // End of tar
              
              // Read tar header (512 bytes)
              const nameBytes = decompressed.slice(offset, offset + 100);
              const name = new TextDecoder().decode(nameBytes).split('\0')[0];
              const sizeBytes = decompressed.slice(offset + 124, offset + 136);
              const sizeStr = new TextDecoder().decode(sizeBytes).trim().replace(/\0/g, '');
              const size = parseInt(sizeStr, 8) || 0;
              
              // Handle PAX extended attributes (files starting with ././@PaxHeader)
              if (name.startsWith('././@PaxHeader') || name.includes('@PaxHeader')) {
                // Skip PAX headers to avoid malformed attribute warnings
                const dataStart = offset + 512;
                const dataEnd = dataStart + size;
                const paddedEnd = dataEnd + (512 - (size % 512)) % 512;
                offset = paddedEnd;
                continue;
              }
              
              const dataStart = offset + 512;
              const dataEnd = dataStart + size;
              const paddedEnd = dataEnd + (512 - (size % 512)) % 512;
              
              // Skip /static directory and its contents
              if (!name.includes('/static/') && !name.endsWith('/static')) {
                // Copy the entire block (header + data + padding)
                const block = decompressed.slice(offset, paddedEnd);
                newTarBlocks.push(block);
              }
              
              offset = paddedEnd;
            }
            
            updateProgress(70, 'Rebuilding tar archive...');
            
            // Calculate total size
            let totalSize = 0;
            for (const block of newTarBlocks) {
              totalSize += block.length;
            }
            totalSize += 1024; // Add end-of-archive markers
            
            // Create new tar
            const newTar = new Uint8Array(totalSize);
            let writeOffset = 0;
            
            // Copy all blocks
            for (const block of newTarBlocks) {
              newTar.set(block, writeOffset);
              writeOffset += block.length;
            }
            
            // Add end-of-archive markers (two blocks of zeros)
            writeOffset += 1024;
            
            updateProgress(85, 'Compressing...');
            
            // Compress back to gzip
            const compressed = pako.gzip(newTar, { level: 6 });
            
            updateProgress(95, 'Creating new file...');
            
            // Create new file
            const cleanedFile = new File([compressed], file.name, { type: 'application/gzip' });
            
            return cleanedFile;
          }

          uploadForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!fileInput.files.length) {
              alert('Please select a file');
              return;
            }
            
            let file = fileInput.files[0];
            const originalSize = file.size;
            
            // Check if it's a tar.gz file
            const isTarGz = file.name.endsWith('.tar.gz') || file.name.endsWith('.tgz');
            
            if (isTarGz) {
              showProgress();
              
              try {
                // Clean the file
                file = await cleanTarGz(file);
                const newSize = file.size;
                const savedMB = ((originalSize - newSize) / 1024 / 1024).toFixed(2);
                
                updateProgress(100, `Cleaned! Removed ${savedMB}MB`);
                
                // Wait a bit to show the success message
                await new Promise(resolve => setTimeout(resolve, 500));
                
              } catch (error) {
                console.error('Error cleaning file:', error);
                if (error.message.includes('not loaded')) {
                  alert('Compression library failed to load. Please refresh the page and try again.');
                } else {
                  alert('Error processing file. Uploading original instead.');
                }
                hideProgress();
              }
            }
            
            // Check final size
            if (file.size > 5 * 1024 * 1024) {
              hideProgress();
              alert("Too big! 5MB max. Even after removing /static, your file is too large.");
              return;
            }
            
            // Submit the cleaned file
            const formData = new FormData();
            formData.append('olxfile', file);
            formData.append('course_id', document.getElementById('course_id').value);
            formData.append('studio_base_url', document.getElementById('studio_base_url').value);
            
            if (!isTarGz) {
              updateProgress(50, 'Uploading...');
              showProgress();
            }
            
            try {
              const response = await fetch('/upload', {
                method: 'POST',
                body: formData
              });
              
              if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                window.location.href = url;
              } else {
                alert('Upload failed: ' + response.statusText);
                hideProgress();
              }
            } catch (error) {
              alert('Upload error: ' + error.message);
              hideProgress();
            }
          });

          // Clean and Download button handler
          cleanBtn.addEventListener('click', async function() {
            if (!fileInput.files.length) {
              alert('Please select a file');
              return;
            }
            
            let file = fileInput.files[0];
            const originalSize = file.size;
            
            // Check if it's a tar.gz file
            const isTarGz = file.name.endsWith('.tar.gz') || file.name.endsWith('.tgz');
            
            if (!isTarGz) {
              alert('Clean and Download only works with .tar.gz and .tgz files.');
              return;
            }
            
            showProgress();
            
            try {
              // Clean the file
              file = await cleanTarGz(file);
              const newSize = file.size;
              const savedMB = ((originalSize - newSize) / 1024 / 1024).toFixed(2);
              
              updateProgress(100, `Cleaned! Removed ${savedMB}MB`);
              
              // Wait a bit to show the success message
              await new Promise(resolve => setTimeout(resolve, 500));
              
              // Download the cleaned file
              const url = window.URL.createObjectURL(file);
              const a = document.createElement('a');
              a.href = url;
              a.download = file.name.replace('.tar.gz', '_cleaned.tar.gz').replace('.tgz', '_cleaned.tgz');
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);
              
              hideProgress();
              
            } catch (error) {
              console.error('Error cleaning file:', error);
              if (error.message.includes('not loaded')) {
                alert('Compression library failed to load. Please refresh the page and try again.');
              } else {
                alert('Error processing file: ' + error.message);
              }
              hideProgress();
            }
          });
          </script>
    </div>
</body>
</html> 